#!/bin/sh

. /etc/reimu.conf
. /libexec/gpio-funcs

# Note: on 64 MB flash, we have phosphor-ledmanager, so we should control UID through DBus.
# Otherwise, we should directly drive the corresponding GPIO line.
# TinySPI boards should NEVER have it, because UID is controlled through CPLD,
# so we can't use phosphor-ledmanager to control UID.

LEDMAN=`pidof phosphor-ledmanager > /dev/null && echo "yes" || echo "no"`

uid_set_dbus()
{
    [ "$1" = "off" ] && state=false
    [ "$1" = "on" ]  && state=true
    busctl call xyz.openbmc_project.LED.GroupManager /xyz/openbmc_project/led/groups/enclosure_identify org.freedesktop.DBus.Properties Set ssv xyz.openbmc_project.Led.Group Asserted b $state
    exit $?
}

uid_get_dbus()
{
    state=`busctl call xyz.openbmc_project.LED.GroupManager /xyz/openbmc_project/led/groups/enclosure_identify org.freedesktop.DBus.Properties Get ss xyz.openbmc_project.Led.Group Asserted | cut -d" " -f3`
    test "$state" != "true"
}

uid_set_gpio()
{
    [ "$1" = "off" ] && trig=none
    [ "$1" = "on" ]  && trig=default-on
    echo $trig > "/sys/class/leds/platform:blue:uid/trigger"
}

uid_get_gpio()
{
    test `cat "/sys/class/leds/platform:blue:uid/brightness"` -eq 0
}

uid_switch_gpio()
{
    uid_get_gpio && uid_set_gpio on || uid_set_gpio off
}

uid_switch_tspi()
{
    uid_get_tspi && uid_set_tspi on || uid_set_tspi off
}

uid_switch_dbus()
{
    uid_get_dbus && uid_set_dbus on || uid_set_dbus off
}

uid_set_tspi()
{
    modprobe tinyspi # Just in case module is not loaded
    [ "$1" = "off" ] && bits=00000008
    [ "$1" = "on" ]  && bits=00000004
    echo $bits > /sys/kernel/tinyspi/command_bits_set
    sleep 1
    echo $bits > /sys/kernel/tinyspi/command_bits_reset
}

uid_get_tspi()
{
    modprobe tinyspi # Just in case module is not loaded
    test $((0x`cat /sys/kernel/tinyspi/state_reg` & 0x00000008)) -eq 0
}

query_uid()
{
    if [ "$LEDMAN"  = "yes" ]
    then
        uid_get_dbus
    else
        if [ "$TINYSPI" = "yes" ]
        then
            uid_get_tspi
        else
            uid_get_gpio
        fi
    fi
}

usage()
{
[ "$@" ] && echo $@
cat << EOF
    Unit ID management utility for REIMU, version 0.1.
    Usage:
        $0 off    - to set UID state off.
        $0 on     - to set UID state on.
        $0 switch - to invert current UID state.
        $0 query  - to query UID state (return code: 0 = off, 1 = on).
        $0 show   - to do the same as 'query', but also show UID state in terminal.
EOF
exit 0
}

ledtype="$1"
case "$ledtype" in
    "on")
        [ "$LEDMAN"  = "yes" ] && uid_set_dbus on
        [ "$TINYSPI" = "yes" ] && uid_set_tspi on || uid_set_gpio on
        ;;
    "off")
        [ "$LEDMAN"  = "yes" ] && uid_set_dbus off
        [ "$TINYSPI" = "yes" ] && uid_set_tspi off || uid_set_gpio off
        ;;
    "query")
        query_uid
        ;;
    "show")
        query_uid
        RV=$?
        [ $RV -eq 0 ] && echo "UID is OFF" || echo "UID is ON"
        exit $RV
        ;;
    "switch")
        [ "$LEDMAN"  = "yes" ] && uid_switch_dbus
        [ "$TINYSPI" = "yes" ] && uid_switch_tspi || uid_switch_gpio
        ;;
    ""|"-h"|"--help")
        usage
        ;;
    *)
        usage "You should specify a correct command."
        ;;
esac
