#!/bin/sh
### BEGIN INIT INFO
# Provides:          overheatd
# Required-Start:    initsc
# Required-Stop:
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: starts overheatd
# Description:       starts overheat control daemon
### END INIT INFO

rundir="/run"
pidfile=$rundir/overheatd.pid
rawi2ctool="/usr/bin/rawi2ctool"

. /libexec/gpio-funcs

# If no configfile exist, create it there
configfile="/etc/overheatd.conf"
if [ ! -f $configfile ]
then
    echo "OVERHEATD_ENABLED=yes"   >> $configfile
    echo "DEBUG=off"               >> $configfile
    echo "CPU_TEMP_LIMIT=85"       >> $configfile
    echo "WAIT_USEC=500000"        >> $configfile
    echo "BLINK_SECONDS=2"         >> $configfile
    echo "CPU_I2C_NUM=3"           >> $configfile
fi
. $configfile

statefile="/var/volatile/systemstate.xml"

debug()
{
    [ "$DEBUG" = "on" ] && echo "$0 (`date`): $@"
}

case "$1" in
    start)
        [ "$OVERHEATD_ENABLED" = "no" ] && exit 0
        [ ! -f $pidfile ] && $0 --daemon &
        exit 0
        ;;
    stop)
        [ -f $pidfile ] && kill `cat $pidfile`
        exit 0
        ;;
    restart)
        $0 stop
        sleep 1
        $0 start
        exit 0
        ;;
    status)
        if [ -f $pidfile ]
        then
            if [ -d /proc/`cat $pidfile` ]
            then
                echo `basename $0` is running.
                exit 0
            else
                echo `basename $0` is not running, but pidfile still exists.
                exit 2
            fi
        else
            echo `basename $0` is not running.
            exit 1
        fi
        ;;
    --daemon)
        [ "$OVERHEATD_ENABLED" = "no" ] && exit 0
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|status}"
        exit 2
        ;;
esac

rm_pidfile()
{
    [ -f $pidfile ] && rm $pidfile
    exit 0
}
trap rm_pidfile TERM INT EXIT
mkdir -p $rundir
echo $$ > $pidfile

. /etc/reimu.conf

if [ "$TINYSPI" = "yes" ]
then
    modprobe tinyspi # Just in case module is not loaded
    sysfsdir="/sys/kernel/tinyspi"
fi

led_state=unknown
led_trigger=unknown
alerts=unknown

get_gpio()
{
    gpionum=`gpio2num $1`
    gpioread $gpionum
    gpiounexport $gpionum
}

bin2hex()
{
    case $1 in
        0000) echo -n '0';;
        0001) echo -n '1';;
        0010) echo -n '2';;
        0011) echo -n '3';;
        0100) echo -n '4';;
        0101) echo -n '5';;
        0110) echo -n '6';;
        0111) echo -n '7';;
        1000) echo -n '8';;
        1001) echo -n '9';;
        1010) echo -n 'a';;
        1011) echo -n 'b';;
        1100) echo -n 'c';;
        1101) echo -n 'd';;
        1110) echo -n 'e';;
        1111) echo -n 'f';;
    esac
}

overheat_set_led_gpio()
{
    echo $1 > "/sys/class/leds/platform:red:fanfail/trigger"
    echo $1 > "/sys/class/leds/platform:red:fanfail2/trigger"
    debug "Changed LED state trigger to $1 through sysfs (/sys/class/leds/platform:red:{fanfail,fanfail2}/trigger)"
}

overheat_set_led_tspi()
{
    if [ $1 -eq 1 ]
    then
        ledfile=command_bits_reset
    else
        ledfile=command_bits_set
    fi
    echo 0x00000040 > $sysfsdir/$ledfile
    debug "Changed LED state through $ledfile"
}

while true
do
    # Reload config (done each cycle)
    . $configfile
    debug "Reloaded config: ($DEBUG;$CPU_TEMP_LIMIT;$WAIT_USEC;$BLINK_SECONDS;$CPU_I2C_NUM) from $configfile"
    # We won't automatically exit if OVERHEATD_ENABLED is set to "no", so we don't check it here.

    # Recreate statefile
    echo "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" > $statefile.tmp
    echo "<state date=\"`date`\">" >> $statefile.tmp

    # Set I2C bus speed correctly
    i2c_config_dword=0x77744303
    case $CPU_I2C_NUM in
        0) # REIMU I2C1
            i2c_reg_address=0x1e78a044; ;;
        1) # REIMU I2C2
            i2c_reg_address=0x1e78a084; ;;
        2) # MUS-A I2C3, REIMU I2C3
            i2c_reg_address=0x1e78a0c4; ;;
        3) # MUS-A I2C4 (E8C-uATX/SE), REIMU I2C4
            i2c_reg_address=0x1e78a104; ;;
        4) # REIMU I2C5
            i2c_reg_address=0x1e78a144; ;;
        5) # MUS-A I2C0 (E8C-EATX, E8C-SWTX), REIMU I2C6
            i2c_reg_address=0x1e78a184; ;;
        6) # MUS-A I2C1, REIMU I2C7
            i2c_reg_address=0x1e78a1c4; ;;
        7) # MUS-A I2C2, REIMU I2C8
            i2c_reg_address=0x1e78a304; ;;
        8) # REIMU I2C9
            i2c_reg_address=0x1e78a344; ;;
        9) # REIMU I2C10
            i2c_reg_address=0x1e78a384; ;;
        13) # REIMU I2C14
            i2c_reg_address=0x1e78a484; ;;
    esac
    devmem $i2c_reg_address w $i2c_config_dword # Default I2C speed is too low for CPU sensor; just in case it is still default

    # default: off
    oldledstate=$led_state
    oldledtrigger=$led_trigger
    led_state=0
    led_trigger=none

    if [ "$TINYSPI" = "yes" ]
    then
        tinyspi_alert=`get_gpio $GPIO_TINYSPI_ALERT`
        if [ "$alerts" = "unknown" -o $tinyspi_alert -eq 0 ] # Re-check alerts only if we have TINYSPI_ALERT
        then
            debug "Re-reading alerts (tinyspi_alert = $tinyspi_alert, old alerts = $alerts)"
            echo 0x00000010 > $sysfsdir/command_bits_set
            echo 0x00000010 > $sysfsdir/command_bits_reset
            alerts=0x`cat $sysfsdir/state_reg`
        fi
    else
        debug "Re-reading alerts (old alerts = $alerts)"
        # TinySPI has the following assignment, so we try to adopt it:
        # INTRUSION_SW# = bit 4  = INTRUSION_SW#
        # I2C0_ALERT#   = bit 6  = ALERT_MEM#
        # I2C1_ALERT#   = bit 8  = ALERT_SMBUS#
        # I2C1_TCRIT#   = bit 9  = TCRIT_SMBUS#
        # I2C1_FAULT#   = bit 10 = ALERT_FRU#
        # I2C2_ALERT#   = bit 11 = ALERT_PCIE#
        # I2C3_ALERT#   = bit 12 = ALERT_CPU2#
        # I2CM_ALERT#   = bit 14 = ALERT_CPU#
        # PWROK_MAIN    = bit 21 = PWROK_ATX
        # APMDZ_LED#    = bit 21 = APMDZ_LED#
        # GPI[7] (RFU)  = bit 31 = PLT_RST#

        b21=`get_gpio $GPIO_APMDZ_LED`
        b21=`get_gpio $GPIO_POWER_IN`
        b31=`get_gpio $GPIO_RESET_IN`
        b14=`get_gpio $GPIO_ALERT_CPU`
        b12=`get_gpio $GPIO_ALERT_CPU2`
        b06=`get_gpio $GPIO_ALERT_MEM`
        b11=`get_gpio $GPIO_ALERT_PCIE`
        b10=`get_gpio $GPIO_ALERT_FRU`
        b08=`get_gpio $GPIO_ALERT_SMBUS`
        b09=`get_gpio $GPIO_TCRIT_SMBUS`
        b04=`get_gpio $GPIO_INTRUSION`
        h1=`bin2hex 1${b06}1${b04}`
        h2=`bin2hex ${b11}${b10}${b09}${b08}`
        h3=`bin2hex 1${b14}1${b12}`
        h5=`bin2hex ${b23}0${b21}1`
        h7=`bin2hex ${b31}000`
        alerts=0x${h7}0${h5}0${h3}${h2}${h1}5
    fi

    debug "Alerts: $alerts"
    echo "	<alerts>$alerts</alerts>" >> $statefile.tmp

    # THERMAL_SHDN == 0 : on
    if [ $(($alerts & 0x00000001)) -eq 0 ]  # Bit 0: THERMAL_SHDN#
    then
        led_state=1
    fi

    # I2CM_TTRIP == 0 & PWROK_MAIN == 1 : on
    if [ $(($alerts & 0x00008000)) -eq 0 ] # Bit 15: I2CM_TTRIP
    then
        if [ ! $(($alerts & 0x00200000)) -eq 0 ]  # Bit 21: PWROK_MAIN
        then
            led_state=1
        fi
    fi
    debug "led_state after checking TTRIP: $led_state"

    if [ $led_state -eq 0 ] # We are not in critical overheat, so check I2C
    then
        # Detect available cpus
        cpus=""
        for j in `seq 2 5`
        do
            debug "exec: rawi2ctool -W $CPU_I2C_NUM 0x${j}0 2> /dev/null && cpus=\"$cpus $j\""
            $rawi2ctool -W $CPU_I2C_NUM 0x${j}0 2> /dev/null && cpus="$cpus $j"
        done
        debug "Bus $CPU_I2C_NUM, CPUs detected: $cpus"
        echo "	<cpus>$cpus</cpus>" >> $statefile.tmp

        # Check temperature of each cpu core
        maxtemp=0
        for cpu in $cpus
        do
            for core in `seq 0 7`
            do
                temp=$((0x`$rawi2ctool -r -w $CPU_I2C_NUM 0x${cpu}${core} | sed 's/ //'` / 8))
                debug "Temp ($cpu:$core): $temp"
                echo "	<temperature cpu=\"$cpu\" core=\"$core\">$temp</temperature>" >> $statefile.tmp
                [ $temp -gt $maxtemp ] && maxtemp=$temp
            done
        done
        debug "maxtemp: $maxtemp"

        # Any of temperatures is greater than /mnt/data/etc/cpu_temp_limit
        if [ $maxtemp -gt $CPU_TEMP_LIMIT ]
        then
            led_trigger="timer"
            led_state=`expr 1 - $oldledstate`
        else
            led_trigger="none"
        fi
    else
        led_trigger="default-on"
    fi

    # Update led, if needed
    debug "LED state: $oldledstate -> $led_state"
    debug "LED trigger: $oldledtrigger -> $led_trigger"
    if [ $oldledstate != $led_state -a "$TINYSPI" = "yes" ]
    then
        overheat_set_led_tspi $led_state
    fi
    if [ $oldledtrigger != $led_trigger -a "$TINYSPI" = "no" ]
    then
        overheat_set_led_gpio $led_trigger
    fi

    # Finalize statefile
    echo "</state>" >> $statefile.tmp
    mv $statefile.tmp $statefile

    # Sleep till next cycle
    usleep $WAIT_USEC
done
